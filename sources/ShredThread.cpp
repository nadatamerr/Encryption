#include <ShredThread.h>

ShredThread::ShredThread (FileSpooler * p_fileSpooler,  char * p_key_file_name,  char * p_iv_file_name, const char * p_file_name,uint16_t block_size,MultiHeadQueue  <sb_block_index_t> * p_multiHeadQueue,char p_shred_name,bool truncate):Thread(), Shred(p_file_name,block_size,truncate)
{//initialize the class members using parameters given
        srcFileSpooler = p_fileSpooler;
        key_file_name = p_key_file_name;
        iv_file_name = p_iv_file_name;
        multiHeadQueue = p_multiHeadQueue;
        shred_name = p_shred_name;
}
void ShredThread::mainThreadBody(){}
ShredThread::~ShredThread(){}

EncryptShredThread::EncryptShredThread (FileSpooler * p_fileSpooler,  char * p_key_file_name,  char * p_iv_file_name,const char * p_file_name,uint16_t block_size,Lottery * p_lottery,MultiHeadQueue  <sb_block_index_t> * p_multiHeadQueue,char p_shred_name,bool truncate) : ShredThread(p_fileSpooler, p_key_file_name, p_iv_file_name,p_file_name,block_size,p_multiHeadQueue,p_shred_name,truncate)
{
    lottery = p_lottery;//initialize lottery using parameters given
}
void EncryptShredThread::mainThreadBody()
{
	//This function needed to be implemented by you 

    CryptoPP::byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ],//create variable to store key
    iv[ CryptoPP::AES::BLOCKSIZE ];//create variable to store iv
    memset( key, 0x00, CryptoPP::AES::DEFAULT_KEYLENGTH );//initialize key
    memset( iv, 0x00, CryptoPP::AES::BLOCKSIZE );//initalize iv
    
    ifstream ivf;
    ivf.open(iv_file_name,ios::in);//open iv file
    if(ivf.is_open()){//check it was open successfully
        ivf.read (reinterpret_cast<char*>(iv),sizeof(iv));//read iv from file
        ivf.close();
    }

    ifstream kf;
    kf.open(key_file_name,ios::in);//open key file
    if ( kf.is_open())//check it was open successfully
    {
        kf.read (reinterpret_cast<char*>(key),sizeof(key)); //read key from file
        kf.close();
        
    }
    else
        cout << "Unable to open key file.\n";
    
    long e = lottery->withdraw();//generate random number from lottery

    for (int i= 0; e != -1 ; i++)//loop until lottery returns -1, which means there are no more blocks
    {
        Block *b = (*srcFileSpooler)[e];//store pointer to block of corresponding index generated by lottery 
        b->encrypt(key,iv);//encrypt block 
        
        *(this) << *b; //store encrypted block in this shred

        sb_block_index_t s;//create object of type sb_block_index_t
        s.block = e ; //block index number is the number generated by the lottery
        s.shred = shred_name;//shred name is the shred executing this function at any point in time
        s.shred_block = i ; //block number in this shred

        multiHeadQueue->enqueue(s);//add the object of th struct into the queue

        delete(b); 
		
		e = lottery->withdraw(); //get another block number from the lottery

    }
    


    
}
EncryptShredThread::~EncryptShredThread()
{
    

}

DecryptShredThread::DecryptShredThread (FileSpooler * p_fileSpooler,  char * p_key_file_name,  char * p_iv_file_name,const char * p_file_name,uint16_t block_size,MultiHeadQueue  <sb_block_index_t> * p_multiHeadQueue,char p_shred_name,bool truncate): ShredThread(p_fileSpooler, p_key_file_name, p_iv_file_name,p_file_name,block_size,p_multiHeadQueue,p_shred_name,truncate)
{
    

}
Block * DecryptShredThread::operator [] (int index)
{
    return (*fileSpooler)[index];//returns pointer to the block that will be decrypted
}

void DecryptShredThread::mainThreadBody()
{
        //This function needed to be implemented by you

    CryptoPP::byte key[ CryptoPP::AES::DEFAULT_KEYLENGTH ], iv[ CryptoPP::AES::BLOCKSIZE ];//create variables to store key and iv
    memset( key, 0x00, CryptoPP::AES::DEFAULT_KEYLENGTH );//initialize key
    memset( iv, 0x00, CryptoPP::AES::BLOCKSIZE );//initialize iv
    ifstream f;
    f.open(key_file_name,ios::in);//open key file
    if ( f.is_open())//check file is open successfully
    {
        f.read (reinterpret_cast<char*>(key),sizeof(key)); //read key from file
        f.close();
    }
    else
        cout << "Unable to open key file.\n";

    
    f.open(iv_file_name,ios::in);//open iv file
    if ( f.is_open())
    {
        f.read (reinterpret_cast<char*>(iv),sizeof(iv));//read iv from file
        f.close();
    }
    else
        cout << "Unable to open iv file.\n";
   
    Block *b = NULL;
    sb_block_index_t s; //create variable of type sb_block_index_t
    s.shred = shred_name;//shred name is the shred executing this function at any point in time
    bool check = multiHeadQueue->dequeue (s, [](sb_block_index_t &a, sb_block_index_t &b)->bool{
        if(a.shred == b.shred) {
            return true;
        } else {
            return false;
        }
    });
    //call dequeue from class multiheadqueue
    //use lambda function to check that the item was passed is equal to item in queue
    
    for (int i= 0; check == true ; i++)
    {
        b = (*this)[s.shred_block];//returns pointer to block to decrypt it
        if(b==NULL)break;
        b->decrypt(key,iv);//decrypt block
        srcFileSpooler->writeBlockAt(b,s.block);//call function write block at to move to correct position in he output file and write the decrypted block
        delete(b);
        check = multiHeadQueue->dequeue (s, [](sb_block_index_t &a, sb_block_index_t &b)->bool{
            if(a.shred == b.shred) {
                return true;
            } else {
                return false;
            }
        }); //call dequeue from class multiheadqueue
    //use lambda function to check that the item was passed is equal to item in queue
    
    }
}
DecryptShredThread::~DecryptShredThread()
{
    
}
